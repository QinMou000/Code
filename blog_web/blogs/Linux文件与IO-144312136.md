<blockquote> <br> <p style="text-align:center;"><img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/a46182e6318c4593a5c674f2bf9439d4.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12799988.html" title="Linux">Linux</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2 style="background-color:transparent;"><span style="color:#0d0016;">理解文件</span></h2> <br><ul><li><span style="color:#0d0016;">⽂件在磁盘⾥ </span></li><li><span style="color:#0d0016;">磁盘是永久性存储介质，因此⽂件在磁盘上的存储是永久性的 </span></li><li><span style="color:#0d0016;">磁盘是外设（即是输出设备也是输⼊设备） </span></li><li><span style="color:#0d0016;">磁盘上的⽂件本质是对⽂件的所有操作，都是对外设的输⼊和输出简称 IO</span></li><li><span style="color:#0d0016;">文件 = 文件属性 + 文件内容</span></li><li><span style="color:#0d0016;">0 kb的空文件也是在磁盘中占用空间的</span></li><li><span style="color:#0d0016;">对文件的操作无非都是<strong>进程对属性的操作和对内容的操作</strong></span></li><li><span style="color:#0d0016;">磁盘的管理者是操作系统</span></li><li> <br>  <div> <br>   <span style="color:#0d0016;">⽂件的读写本质不是通过 C 语⾔ / C++ 的库函数来操作的（这些库函数只是为⽤户提供⽅便），⽽是通过⽂件相关的系统调⽤接⼝来实现的</span> <br>  </div> </li></ul> <br><p><span style="color:#0d0016;">广义上对文件的理解：可以认为在</span><span style="color:#ed7976;"><em>Linux</em></span><span style="color:#0d0016;">下一切皆文件（键盘，显示器，网卡，磁盘……）</span><span style="color:#ed7976;"><em>Linux</em></span><span style="color:#0d0016;">下都把它们做了抽象。</span></p> <br><h2><span style="color:#0d0016;">回顾C语言的文件操作</span></h2> <br><p><span style="color:#0d0016;"> 回顾C语言文件操作接口：<a href="https://blog.csdn.net/2301_80194476/article/details/137158855" title="C语言中的文件和文件操作">C语言中的文件和文件操作</a></span></p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td> <p><span style="color:#0d0016;">文件操作函数</span></p> </td><td><span style="color:#0d0016;">    功能</span></td></tr><tr><td><span style="color:#0d0016;">fopen</span></td><td><span style="color:#0d0016;">打开文件</span></td></tr><tr><td><span style="color:#0d0016;">fclose</span></td><td><span style="color:#0d0016;">关闭文件</span></td></tr><tr><td><span style="color:#0d0016;">fputc</span></td><td><span style="color:#0d0016;">写入一个字符</span></td></tr><tr><td><span style="color:#0d0016;">fgetc</span></td><td><span style="color:#0d0016;">读取一个字符</span></td></tr><tr><td><span style="color:#0d0016;">fputs</span></td><td><span style="color:#0d0016;">写入一个字符串</span></td></tr><tr><td><span style="color:#0d0016;">fgets</span></td><td><span style="color:#0d0016;">读取一个字符串</span></td></tr><tr><td><span style="color:#0d0016;">fprintf</span></td><td><span style="color:#0d0016;">格式化写入数据</span></td></tr><tr><td><span style="color:#0d0016;">fscanf</span></td><td><span style="color:#0d0016;">格式化读取数据</span></td></tr><tr><td><span style="color:#0d0016;">fwrite</span></td><td><span style="color:#0d0016;">向二进制文件写入数据</span></td></tr><tr><td><span style="color:#0d0016;">fread</span></td><td><span style="color:#0d0016;">从二进制文件读取数据</span></td></tr><tr><td><span style="color:#0d0016;">fseek</span></td><td><span style="color:#0d0016;">设置文件指针的位置</span></td></tr><tr><td><span style="color:#0d0016;">ftell</span></td><td><span style="color:#0d0016;">计算当前文件指针相对于起始位置的偏移量</span></td></tr><tr><td><span style="color:#0d0016;">rewind</span></td><td><span style="color:#0d0016;">设置文件指针到文件的起始位置</span></td></tr><tr><td><span style="color:#0d0016;">ferro</span></td><td><span style="color:#0d0016;">判断文件操作过程中是否发生错误</span></td></tr><tr><td><span style="color:#0d0016;">feof</span></td><td><span style="color:#0d0016;">判断文件指针是否读取到文件末尾</span></td></tr></tbody></table> <br><p> 打开一个文件的模式：</p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:134px;"><span style="color:#0d0016;">文件使用方式</span></td><td style="width:310px;"><span style="color:#0d0016;">含义</span></td><td><span style="color:#0d0016;">如果指定文件不存在</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“r”（只读）   </span></td><td style="width:310px;"><span style="color:#0d0016;"> 为了输⼊数据，打开⼀个已经存在的⽂本⽂件  </span></td><td><span style="color:#0d0016;"> 出错</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“w”（只写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了输出数据，打开⼀个⽂本⽂件</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“a”（追加）  </span></td><td style="width:310px;"><span style="color:#0d0016;"> 向⽂本⽂件尾添加数据   </span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“rb”（只读）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了输⼊数据，打开⼀个⼆进制⽂件</span></td><td><span style="color:#0d0016;">出错</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“wb”（只写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了输出数据，打开⼀个⼆进制⽂件</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“ab”（追加）</span></td><td style="width:310px;"><span style="color:#0d0016;">向⼀个⼆进制⽂件尾添加数据</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“r+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了读和写，打开⼀个⽂本⽂件</span></td><td><span style="color:#0d0016;">出错</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“w+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了读和写，建议⼀个新的⽂件</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“a+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">打开⼀个⽂件，在⽂件尾进⾏读写</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“rb+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了读和写打开⼀个⼆进制⽂件</span></td><td><span style="color:#0d0016;">出错</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“wb+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了读和写，新建⼀个新的⼆进制⽂件</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“ab+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">打开⼀个⼆进制⽂件，在⽂件尾进⾏读和写</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr></tbody></table> <br><p>示例</p> <br><pre><code class="language-cpp">#include<stdio.h><br>int main()<br>{<br>    FILE*fp=fopen("log.txt","w");<br>    if(fp==NULL)<br>    {<br>        perror("fopen fail:");<br>        return 1;<br>    }<br>    //open success<br>    const char*msg="hello Qin!\n";<br>    int count=5;<br>    while(count--)<br>    {<br>        fputs(msg,fp);<br>    }<br>    fclose(fp);<br>    return 0;<br>}<br></code></pre> <br><p>进程在当前目录下新建文件并写入 </p> <br><p><img alt="" height="396" src="https://i-blog.csdnimg.cn/direct/215ffb7f457642059090d1bf449d45c9.png" width="817" /><img alt="" height="238" src="https://i-blog.csdnimg.cn/direct/e61002f9bb1649b0aaeec4b4585464f4.png" width="829" /></p> <br><p><span style="color:#0d0016;">一般而言如果没有定义对应</span><span style="color:#ed7976;"><em>log.txt</em></span><span style="color:#0d0016;">文件，系统会在当前路径自动创建该文件。并且当前路径并不是指可执行程序所处的路径，而是指该可执行程序运行成为进程时我们所处的路径。</span>并且当前路径并不是指可执行程序所处的路径，而是指该可执行程序运行成为进程时我们所处的路径。比如我们可以在上级目录执行<span style="color:#ed7976;"><em>test </em></span>文件：</p> <br><p><img alt="" height="115" src="https://i-blog.csdnimg.cn/direct/c2492edd1a9e4aaca65a62086738efce.png" width="939" /> <span style="color:#0d0016;">打开⽂件，本质是进程打开，所以，进程知道⾃⼰在哪⾥（环境变量</span><span style="color:#ed7976;"><em>cwd </em></span><span style="color:#0d0016;">等等），即便⽂件不带路径，进程也知道。由此</span><span style="color:#ed7976;"><em>OS </em></span><span style="color:#1f2329;">就能知道要创建的⽂件放在哪⾥。</span></p> <br><p><span style="color:#1f2329;">可以使⽤ </span><span style="color:#ed7976;"><em>ls /proc/[进程id] -l</em></span><span style="color:#1f2329;"> </span><span style="color:#1f2329;">命令查看当前正在运⾏进程的信息：</span>  </p> <br><p><img alt="" height="422" src="https://i-blog.csdnimg.cn/direct/fae123f6b5214cd69f2409f8882060d3.png" width="866" /></p> <br><p>然后我们可以看见两个软连接</p> <br><ul><li><span style="color:#ed7976;"><em>cwd</em></span>：<span style="color:#646a73;">指向当前进程运⾏⽬录的⼀个符号链接。</span></li><li><span style="color:#ed7976;"><em>exe</em></span>：<span style="color:#646a73;">指向启动当前进程的可执⾏⽂件（完整路径）的符号链接。</span></li></ul> <br><h2> 三个默认打开流</h2> <br><p>我们常说<span style="color:#ed7976;"><em>Linux</em></span>下一切皆文件，那么我们的键盘与显示器自然也是文件。我们向键盘输入数据，本质就是操作系统向键盘文件中读取数据；我们能从显示器看见数据，本质就是操作系统向显示器文件写入数据。但是我们在使用键盘与显示器时并没有手动进行任何文件相关的读写操作，那我们又是如何对键盘文件与显示器文件进行读写的呢？</p> <br><p>答案自然是操作系统自动帮我们打开的，任何进程在运行时，操作系统都会默认打开三个输入输出流，分别为：标准输入流，标准输出流以及标准错误流。<span style="color:#b95514;"><strong>对于C语言分别就是：stdin、stdout以及stderr。对于C++分别就是：cin、cout和cerr，自然其他语言也会有相似的概念，因为这是操作系统所支持的，而不是某个语言所独有的。</strong></span></p> <br><p>我们可以在Linux中的man查看对应的声明：</p> <br><p><img alt="" height="366" src="https://i-blog.csdnimg.cn/direct/039312c2bd43424bb12de05d3c48aeb0.png" width="806" /></p> <br><p>其中标准输入流对应的就是我们的键盘，而标准输出流与标准错误流对应的就是我们显示器。</p> <br><p>其中我们也可以通过<span style="color:#ed7976;"><em>fputs </em></span>函数验证一下：</p> <br><pre><code class="language-cpp">#include<stdio.h><br>int main()<br>{<br>  //向显示器打印<br>  fputs("hello QinMou!\n",stdout);<br>  fputs("hello QinMou!\n",stdout);<br>  fputs("hello QinMou!\n",stdout);<br>  fputs("hello QinMou!\n",stdout);<br>  return 0;<br>}</code></pre> <br><p><img alt="" height="133" src="https://i-blog.csdnimg.cn/direct/3c9bac76365940e3854034dad94dd03a.png" width="506" /></p> <br><h2>系统调用文件接口 </h2> <br><p>在前面我们学习操作系统时知道，为了方便用户使用，一般我们会对系统接口进行封装。我们的文件操作也不例外，像<span style="color:#ed7976;"><em>fopen</em></span>、<span style="color:#ed7976;"><em>fclose </em></span>等接口本质其实对操作系统提供的文件接口的封装。接下来我们就来学习一下系统提供的文件接口。 </p> <br><h3>open函数</h3> <br><p>首先我们来介绍文件打开操作的系统接口。</p> <br><p><img alt="" height="197" src="https://i-blog.csdnimg.cn/direct/ae0d1e82ae0e43ceb61f355ed555652a.png" width="651" /></p> <br><ul><li>pathname：表示打开或者创建的目标文件，若pathname以路径的方式给出，则当需要创建该文件时，就在pathname路径下进行创建。若pathname以文件名的方式给出，则当需要创建该文件时，默认在当前路径下进行创建。</li><li>flags：表示打开文件的方式。</li><li>mode：表示创建文件的默认权限(八进制数)。</li></ul> <br><p> 其中常用文件打开方式有如下几个：</p> <br><table><thead><tr><th>参数选项</th><th>含义</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>以只读的方式打开文件</td></tr><tr><td>O_WRNOLY</td><td>以只写的方式打开文件</td></tr><tr><td>O_APPEND</td><td>以追加的方式打开文件</td></tr><tr><td>O_RDWR</td><td>以读写的方式打开文件</td></tr><tr><td>O_CREAT</td><td>当目标文件不存在时，创建文件</td></tr></tbody></table> <br><p>参数 <span style="color:#ed7976;"><em>flags </em></span>使用了位图的传参方式，如果想同时兼具多个打开方式，可以使用逻辑与 | 链接两个选项。比如说我们想打开文件并且文件不存在时创建文件，可以写成：</p> <br><pre><code class="language-cpp">O_WRNOLY | O_CREAT</code></pre> <br><p>所以我们也可以使用按位与<code>&</code>操作来检测是否设置某个选项：</p> <br><pre><code class="language-cpp">if (flags&O_RDONLY){<br>    //设置了O_RDONLY选项<br>}<br>if (flags&O_WRONLY){<br>    //设置了O_WRONLY选项<br>}<br>if (flags&O_RDWR){<br>    //设置了O_RDWR选项<br>}<br>if (flags&O_CREAT){<br>    //设置了O_CREAT选项<br>}<br>//...<br></code></pre> <br><p>并且如果我们打开的文件已存在就使用两个参数的接口，如果打开的文件不存在就需要使用三个参数的接口，即需要为创建的文件设置默认权限。</p> <br><p><a href="https://blog.csdn.net/2301_80194476/article/details/143259081?spm=1001.2014.3001.5502" title="Linux：权限-CSDN博客">Linux：权限-CSDN博客</a> </p> <br><p>如果我们要为文件设置默认权限，就需要考虑文件默认掩码umask的影响。我们之前讲过文件的默认权限为：mode&(~mask)，我们除了可以在命令行通过指令umask 八进制数来修改默认的掩码umask(默认为002)外，还能在程序中调用umask函数进行修改。比如我们将umask设置为0：</p> <br><pre><code class="language-cpp">umask(0); // 将文件默认掩码设置为0</code></pre> <br><p>最后再来探究一下<span style="color:#ed7976;"><em>open </em></span>的返回值，也就是文件描述符 <em><span style="color:#ed7976;">fd</span></em></p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include <sys/types.h><br>#include <sys/stat.h><br>#include <fcntl.h><br>int main()<br>{<br>    umask(0);//设置文件掩码为0<br>    int fd1 = open("log1.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd2 = open("log2.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd3 = open("log3.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd4 = open("log4.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd5 = open("log5.txt", O_RDONLY | O_CREAT, 0666);<br>	printf("fd1:%d\n", fd1);<br>	printf("fd2:%d\n", fd2);<br>	printf("fd3:%d\n", fd3);<br>	printf("fd4:%d\n", fd4);<br>	printf("fd5:%d\n", fd5);<br>    return 0;<br>}</code></pre> <br><p><img alt="" height="253" src="https://i-blog.csdnimg.cn/direct/1c30425fb0ab41c98a6a10858d9a2dcc.png" width="822" /> </p> <br><p>运行之后我观察到文件描述符是从3开始的，并且依次递增，这起始并不是偶然。0 1 2系统默认给了标准输入，标准输出，标准错误。</p> <br><p>当然这只是文件成功返回的情况，如果文件打开失败，那将返回-1。</p> <br><h3>close函数 </h3> <br><p>我们可以调用系统接口<span style="color:#ed7976;"><em>close </em></span>来关闭指定文件，其原型为： </p> <br><p><img alt="" height="359" src="https://i-blog.csdnimg.cn/direct/71bd68cbdec34c55ac7bfd62f8bad345.png" width="1106" />使用<span style="color:#ed7976;"><em>close</em></span> 函数时传入需要关闭文件的文件描述符即可，若关闭文件成功则返回0，若关闭文件失败则返回-1。 </p> <br><h3> write函数</h3> <br><p>同样我们也能通过系统接口<span style="color:#ed7976;"><em>write </em></span>对文件进行写入，其原型为： </p> <br><p><img alt="" height="185" src="https://i-blog.csdnimg.cn/direct/3d0a4c1e3cc54f70b73ec6674071e2ec.png" width="763" /></p> <br><p>其中<span style="color:#ed7976;"><em>fd </em></span>指的是文件描述符，<span style="color:#ed7976;"><em>buf </em></span>为用户缓冲区，而<span style="color:#ed7976;"><em>count </em></span>为<span style="color:#b95514;"><strong>期望写的字节数。如果写入成功返回实际写入的字节数，若写入失败则返回-1。</strong></span></p> <br><blockquote> <br> <p>注意：ssize_t其实就是一个有符号整型，具体来说就是被typedef重新定义过：typedef int ssize_t</p> <br></blockquote> <br><p>以下我们可以利用write函数对一个log.txt文件进行写入：</p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<unistd.h><br>#include<sys/types.h><br>#include<sys/stat.h><br>#include<fcntl.h><br>#include<string.h><br>int main()<br>{<br>    int fd = open("log.txt",O_WRONLY | O_CREAT);<br>    if(fd < 0)<br>    {<br>        //open error<br>        perror("open fail:");<br>        return 1;<br>    }<br>    const char* msg = "hello QinMou!\n";<br>    for(int i = 0; i < 8; i++)<br>    {<br>        write(fd, msg, strlen(msg));<br>    }<br>    close(fd);<br>    return 0;<br>}<br></code></pre> <br><p><img alt="" height="220" src="https://i-blog.csdnimg.cn/direct/68d043f4b25e4751a783e9ccaac9c086.png" width="731" /></p> <br><h3>read函数 </h3> <br><p>同样我们也能通过系统接口<span style="color:#ed7976;"><em>read</em></span> 对文件进行读写，其原型为： </p> <br><p><img alt="" height="235" src="https://i-blog.csdnimg.cn/direct/ee958bc00b624e0085142083a9ebc7b2.png" width="869" /></p> <br><p>其中<em><span style="color:#ed7976;">fd </span></em>指的是文件描述符，<span style="color:#ed7976;"><em>buf</em></span> 为用户缓冲区，而<span style="color:#ed7976;"><em>count </em></span>为期望读的字节数。如果读出成功返回实际读出的字节数，若读出失败则返回 -1。</p> <br><p>以下我们可以利用<span style="color:#ed7976;"><em>read </em></span>函数对一个<span style="color:#ed7976;"><em>log.txt </em></span>文件进行读出：</p> <br><pre><code class="language-cpp">#include<sys/types.h><br>#include<sys/stat.h><br>#include<fcntl.h><br>#include<string.h><br>int main()<br>{<br>    int fd = open("log.txt", O_RDONLY);<br>    if(fd < 0)<br>    {<br>        perror("open fail:");<br>        return 1;<br>    }<br>    char buf[1024] = {'\0'};<br>    ssize_t ret = read(fd, buf, 1023);<br>    if(ret > 0) printf("%s",buf);<br>    <br>    close(fd);<br>    return 0;<br>}</code></pre> <br><p> <img alt="" height="202" src="https://i-blog.csdnimg.cn/direct/c195816cc30c40e2a448a5984f580c70.png" width="752" /></p> <br><h2>文件描述符——fd </h2> <br><p>在我们的操作系统中，文件是由我们进程所打开的，存在大量进程就意味着存在大量被打开的文件。为了方便我们对文件进行管理，我们就将每个文件<span style="color:#ed7976;"><em>struct file </em></span>链入我们的双向链表之中。 </p> <br><pre><code class="language-cpp">struct File<br>{<br>  //包含了打开文件的相关属性<br>  //链接属性<br>};<br></code></pre> <br><p><img alt="" height="457" src="https://i-blog.csdnimg.cn/direct/690c342169af46baaa42165543d20971.png" width="1063" /></p> <br><p>而一个文件也可能被多个进程所读写，为了让操作系统能够准确识别每个进程对应的文件，我们就一定要让进程与我们的文件建立联系。事实也是如此，我们的进程控制块<span style="color:#ed7976;"><em>task_struct </em></span>中就存在一个指针指向一个名为<em><span style="color:#ed7976;">struct file_struct </span></em>的结构体，这个结构体中存在一个结构体指针数组<span style="color:#ed7976;"><em>struct file*fd_array[] </em></span>分别存放着着每个文件<span style="color:#ed7976;"><em>struct file </em></span>的地址。这样我们的进程就与文件建立起了联系。</p> <br><p><img alt="" height="339" src="https://i-blog.csdnimg.cn/direct/b6c0194390564a75a193ea4621d77f96.png" width="944" /> <img alt="" height="278" src="https://i-blog.csdnimg.cn/direct/2dcabbfc13714c058742a3d6915fe8d2.png" width="718" /></p> <br><p><img alt="" height="848" src="https://i-blog.csdnimg.cn/direct/0fa988e7a5ad4c1daacdbeefbe2a4294.png" width="1200" /></p> <br><p> </p> <br><p>一般我们的指针数组<span style="color:#ed7976;"><em>struct file*fd_array[] </em></span>的<strong><span style="color:#b95514;">0，1，2下标分别对应我们的标准输入流，标准输出流，标准错误流这三个文件</span></strong>，而这些<strong><span style="color:#b95514;">下标就是我们所说的文件描述符——fd。</span></strong>这也解释了我们打开文件的描述符为什么从3开始，并且依次递增。并且，通过对应的文件描述符，进程只需要找到对应的指针数组<em><span style="color:#ed7976;">fd_array </span></em>就能访问对应的文件，这也是为什么我们文件的系统调用接口的参数一定会有<span style="color:#ed7976;"><em>fd </em></span>的原因。</p> <br><p>当然如果我们在中途关掉某个文件，操作系统就会为该下标重新分配对应的文件。 </p> <br><pre><code class="language-cpp">#include <stdio.h><br>#include <sys/stat.h><br>#include <sys/types.h><br>#include <fcntl.h><br>int main()<br>{<br>    close(0);<br>    close(2);<br>	int fd1 = open("log1.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd2 = open("log2.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd3 = open("log3.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd4 = open("log4.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd5 = open("log5.txt", O_RDONLY | O_CREAT, 0666);<br>	printf("fd1:%d\n", fd1);<br>	printf("fd2:%d\n", fd2);<br>	printf("fd3:%d\n", fd3);<br>	printf("fd4:%d\n", fd4);<br>	printf("fd5:%d\n", fd5);<br>	return 0;<br>}<br></code></pre> <br><p> <img alt="" height="128" src="https://i-blog.csdnimg.cn/direct/ce4d49accaa94bcf8840340aa60fcafa.png" width="462" /></p> <br><p>我们也知道，当一个程序运行起来时，操作系统会将该程序的代码和数据加载到内存，然后为其创建对应的<em><span style="color:#ed7976;">task_struct、mm_struct</span></em>、页表等相关的数据结构，并通过页表建立虚拟内存和物理内存之间的映射关系。如果与我们的文件管理联系起来，就是一个磁盘文件<span style="color:#ed7976;"><em>log.txt </em></span>加载进内存形成内存文件，最后加入对应双向链表中管理起来。</p> <br><p><img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/beccafa9b6a84c61b5ca42ee7b9cb165.png" width="1200" /></p> <br><p>当文件存储在磁盘上时，我们称之为磁盘文件。而当磁盘文件被加载到内存中后，就变成了内存文件。磁盘文件与内存文件的关系，恰似程序和进程的关系。程序在运行起来后成为进程，同样，磁盘文件在加载到内存后成为内存文件。磁盘文件主要由两部分构成，即文件内容和文件属性。文件内容指的是文件中存储的数据，而文件属性则是文件的一些基本信息，包括文件名、文件大小以及文件创建时间等。这些文件属性也被称为元信息。在文件加载到内存的过程中，一般会先加载文件的属性信息。这是因为在很多情况下，我们可能只需要了解文件的基本属性，而不一定立即需要对文件内容进行操作。当确实需要对文件内容进行读取、输入或输出等操作时，才会延后式地加载文件数据。这样的设计可以提高系统的效率，避免在不必要的时候浪费资源加载大量的文件数据。</p> <br><p style="text-align:center;"> <strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>