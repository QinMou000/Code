<h2>strncpy：</h2> <br><pre><code class="language-cpp">//模拟实现strncpy<br>char* my_strncpy(char* str1,const char* str2,size_t num)<br>{<br>	assert(str1&&str2);<br>	char* tmp = str1;<br>	while ((*str1++ = *str2++) && --num)<br>		;<br>	if (num)<br>		while (num--)<br>		{<br>			*str1++ = '\0';<br>		}<br>	return tmp;<br>}</code></pre> <br><h2>strncat：</h2> <br><pre><code class="language-cpp">//模拟实现strncat<br>char* my_strncat(char* str1, char* str2, size_t num)<br>{<br>	assert(str1&&str2);<br>	char* tmp = str1;<br>	while (*str1!='\0')<br>		str1++;<br>	while ((*str1++ = *str2++) && --num)<br>		;<br>	if (num)<br>		while (num--)<br>			*str1++ = '\0';<br>	return tmp;<br>}</code></pre> <br><h2>strstr：</h2> <br><pre><code class="language-cpp">//模拟实现strstr<br>char * my_strstr (const char * str1, const char * str2)<br>{<br>    char *cp = (char *) str1;<br>    char *s1, *s2;<br>    if ( !*str2 )<br>        return((char *)str1);<br>    while (*cp)<br>    {<br>        s1 = cp;<br>        s2 = (char *) str2;<br>        while ( *s1 && *s2 && !(*s1-*s2) )<br>        s1++, s2++;<br>        if (!*s2)<br>            return(cp);<br>        cp++;<br>    }<br>    return(NULL);<br>}</code></pre> <br><h2>strtok：</h2> <br><pre><code class="language-cpp">char * strtok ( char * str, const char * sep);</code></pre> <br><p><strong>sep参数指向⼀个字符串，定义了⽤作分隔符的字符集合<br /> • 第⼀个参数指定⼀个字符串，它包含了0个或者多个由sep字符串中⼀个或者多个分隔符分割的标<br /> 记。<br /> • strtok函数找到str中的下⼀个标记，并将其⽤ \0 结尾，返回⼀个指向这个标记的指针。（注：<br /> strtok函数会改变被操作的字符串，所以在使⽤strtok函数切分的字符串⼀般都是临时拷⻉的内容<br /> 并且可修改。）<br /> • strtok函数的第⼀个参数不为 NULL ，函数将找到str中第⼀个标记，strtok函数将保存它在字符串中的位置。<br /> • strtok函数的第⼀个参数为 NULL ，函数将在同⼀个字符串中被保存的位置开始，查找下⼀个标<br /> 记。<br /> • 如果字符串中不存在更多的标记，则返回 NULL 指针。</strong></p> <br><h2>strerror：</h2> <br><pre><code class="language-cpp">#include <errno.h><br>char * strerror ( int errnum );</code></pre> <br><p><strong> strerror函数可以把参数部分错误码对应的错误信息的字符串地址返回来。<br /> 在不同的系统和C语⾔标准库的实现中都规定了⼀些错误码，⼀般是放在 errno.h 这个头⽂件中说明的，C语⾔程序启动的时候就会使⽤⼀个全⾯的变量errno来记录程序的当前错误码，只不过程序启动的时候errno是0，表⽰没有错误，当我们在使⽤标准库中的函数的时候发⽣了某种错误，就会讲对应的错误码，存放在errno中，⽽⼀个错误码的数字是整数很难理解是什么意思，所以每⼀个错误码都是有对应的错误信息的。strerror函数就可以将错误对应的错误信息字符串的地址返回。</strong></p> <br><p><strong>在Windows VS2022环境下：</strong></p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>1</th><th>No error</th></tr></thead><tbody><tr><td>2</td><td>Operation not permitted</td></tr><tr><td>3</td><td>No such file or directory</td></tr><tr><td>4</td><td>No such process</td></tr><tr><td>5</td><td>Interrupted function call</td></tr><tr><td>6</td><td>Input/output error</td></tr><tr><td>7</td><td>No such device or address</td></tr><tr><td>8</td><td>Arg list too long</td></tr><tr><td>9</td><td>Exec format error</td></tr><tr><td>10</td><td>Bad file descriptor</td></tr><tr><td>11</td><td>No child processes</td></tr></tbody></table> <br><h2>memcpy:</h2> <br><pre><code class="language-cpp">//模拟实现memcpy<br>void * my_memcpy ( void * dst, const void * src, size_t count)<br>{<br>    void * ret = dst;<br>    assert(dst);<br>    assert(src);<br>    while (count--)<br>    {<br>        *(char *)dst = *(char *)src;<br>        dst = (char *)dst + 1;<br>        src = (char *)src + 1;<br>    }<br>    return(ret);<br>}</code></pre> <br><h2>memove（这里注意根据dest和sour地址的高低分情况）:</h2> <br><p style="text-align:center;"><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/3b82c45228d3b46f866f83a696cec601.png" /></p> <br><pre><code class="language-cpp">//模拟实现memmove<br>void* my_memmove(void* dest,void* sour,size_t num)<br>{<br>	assert(dest && sour);<br>	char* tmp = (char*)dest;<br>	if (dest == sour)<br>		return dest;<br>	else if (dest < sour)<br>	{<br>		while (num--)<br>		{<br>			*(((char*)dest)++) = *(((char*)sour)++);<br>		}<br>	}<br>	else<br>	{<br>		while (num--)<br>		{<br>			*(((char*) dest) + num) = *(((char*) sour) + num);<br>		}<br>	}<br>	return tmp;<br>}</code></pre> <br><h2>memset:</h2> <br><pre><code class="language-cpp">void * memset ( void * ptr, int value, size_t num );</code></pre> <br><p> memset是⽤来设置内存的，将内存中的值以字节为单位设置成想要的内容。</p> <br><h2>memcmp:</h2> <br><pre><code class="language-cpp">int memcmp ( const void * ptr1, const void * ptr2, size_t num );</code></pre> <br><p>⽐较从ptr1和ptr2指针指向的位置开始，向后的num个字节（和strcmp差不多，memcmp可以比较任何内容）。</p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>